{"version":3,"sources":["../src/index.tsx","../src/utils.ts"],"sourcesContent":["// import { type ClassValue, clsx } from \"clsx\";\nimport React, { forwardRef, type JSX } from \"react\";\nimport { twMerge } from \"tailwind-merge\";\nimport { isRecord, isString, isFunction, omit } from \"./utils\";\nimport { ConvertClassifierToProps } from \"./classifier-types\";\n\n/**\n * tx is a convenience export of tailwind-merge with a similar syntax to `cx` or\n * `clsx`. We don't use `twMerge` to avoid possible conflicts.\n */\nexport { twMerge as tx } from \"tailwind-merge\";\n\nexport type ElementProps<N extends React.ElementType | React.FC> =\n  React.ComponentPropsWithoutRef<N>;\n\ntype MakeOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype JsxElementTagName = { type: \"tag-name\"; tag: keyof JSX.IntrinsicElements };\ntype JsxElementFunctionComponent = { type: \"function-component\"; fn: React.FC };\ntype JsxElement = JsxElementTagName | JsxElementFunctionComponent;\n\n/**\n * Takes the arguments after the first in twux and returns a JsxElement.\n *\n * The return value is a JsxElement.\n */\nfunction getJsxElementFromArgs(\n  ...args: (\n    | keyof JSX.IntrinsicElements\n    | React.FC\n    | Record<string, unknown> // could be a classifier object\n    | undefined\n  )[]\n): JsxElement {\n  for (const arg of args) {\n    if (isString(arg)) return { type: \"tag-name\", tag: arg };\n    if (isFunction(arg)) return { type: \"function-component\", fn: arg };\n  }\n  throw new Error(\n    \"You must provide either a JSX tag (string) or a function component (function) as argument 2, 3, or 4\"\n  );\n}\n\ntype BaseClassifier = Record<string, Record<string, string> | string>;\n\n/**\n * Takes as it's first argument, a set of `props` from an element or function\n * component. We then merge the arguments which are class names into the\n * `className` of the `props` using `twMerge`.\n *\n * The className that is actually on the props takes precedence over the class\n * names that are passed in.\n */\nfunction mergeClassNamesIntoProps<T extends { className?: string }>(\n  { className, ...props }: T,\n  ...classes: Parameters<typeof twMerge>\n): Omit<T, \"className\"> & { className: string } {\n  const nextClassName = twMerge(...classes, className);\n  return { ...props, className: nextClassName };\n}\n\n/**\n * className and tagName\n */\nexport function twux<K extends keyof JSX.IntrinsicElements>(\n  className: string,\n  Tag: K\n): React.FC<JSX.IntrinsicElements[K]>;\n/**\n * className and Function Component\n */\nexport function twux<FCProps extends Record<string, unknown>>(\n  className: string,\n  Component: React.FC<FCProps>\n): React.FC<FCProps>;\n/**\n * className, classifier object and tagName\n */\nexport function twux<\n  K extends keyof JSX.IntrinsicElements,\n  C extends BaseClassifier\n>(\n  className: string,\n  classifier: C,\n  Tag: K\n): React.FC<JSX.IntrinsicElements[K] & ConvertClassifierToProps<C>>;\n/**\n * className, classifier object and Function Component\n */\nexport function twux<\n  FCProps extends Record<string, unknown>,\n  C extends BaseClassifier\n>(\n  className: string,\n  classifier: C,\n  Tag: React.FC<FCProps>\n): React.FC<FCProps & ConvertClassifierToProps<C>>;\n/**\n * className, classifier object, default values and tagName\n */\nexport function twux<\n  K extends keyof JSX.IntrinsicElements,\n  C extends BaseClassifier,\n  D extends Partial<ConvertClassifierToProps<C>>\n>(\n  className: string,\n  classifier: C,\n  defaultValues: D,\n  Tag: K\n): React.FC<\n  JSX.IntrinsicElements[K] &\n    /**\n     * If defaultValues are provided, we need to make the provided defaultValues\n     * optional\n     */\n    MakeOptional<\n      ConvertClassifierToProps<C>,\n      /**\n       * we need to do this because TypeScript can't figure out that keyof D\n       * satisfies the constraint of keyof ConvertClassifierToProps<C>\n       */\n      keyof ConvertClassifierToProps<C> & keyof D\n    >\n>;\n/**\n * className, classifier object, default values and FunctionComponent\n */\nexport function twux<\n  FCProps extends Record<string, unknown>,\n  C extends BaseClassifier,\n  D extends Partial<ConvertClassifierToProps<C>>\n>(\n  className: string,\n  classifier: C,\n  defaultValues: D,\n  Tag: React.FC<FCProps>\n): React.FC<\n  FCProps &\n    /**\n     * If defaultValues are provided, we need to make the provided defaultValues\n     * optional\n     */\n    MakeOptional<\n      ConvertClassifierToProps<C>,\n      /**\n       * we need to do this because TypeScript can't figure out that keyof D\n       * satisfies the constraint of keyof ConvertClassifierToProps<C>\n       */\n      keyof ConvertClassifierToProps<C> & keyof D\n    >\n>;\n/**\n * The arguments for twux are as follows:\n *\n * - className: This is always required\n * - classifier?: An optional object that represents variants of the JSX Element\n *   or Function Component.\n * - defaultValues?: An optional object that represents the default values for\n *   the classifier. Note that the default values cannot be provided without the\n *   classifier first being provided.\n * - Tag (string) | FunctionComponent (React.FC): This is the JSX element or Function Component that\n *   will be rendered.\n *\n * The return value is a new function component that can be used to render the\n * element or function component. It provides the `className` which is added.\n *\n * The combinations of arguments are:\n * - className, Tag | Function Component\n * - className, classifier, Tag | Function Component\n * - className, classifier, defaultClassifierValues, Tag | Function Component\n *\n */\nexport function twux<TagName extends keyof JSX.IntrinsicElements>(\n  className: string,\n  arg2: TagName | React.FC | BaseClassifier,\n  arg3?: TagName | React.FC | Partial<ConvertClassifierToProps<BaseClassifier>>,\n  arg4?: TagName | React.FC\n): React.FC {\n  const maybeClassifier = isRecord(arg2) ? arg2 : undefined;\n  const maybeDefaultValues =\n    maybeClassifier && isRecord(arg3)\n      ? arg3\n      : ({} as Partial<ConvertClassifierToProps<BaseClassifier>>);\n\n  function classify(incomingProps: Record<string, unknown>): string[] {\n    const classNames: string[] = [className];\n    if (!maybeClassifier) return classNames;\n    for (const [key, value] of Object.entries(maybeClassifier)) {\n      if (isString(value)) {\n        /**\n         * If the use passed in a prop that matches the key, then add the\n         * value to the classes array if that prop's value is truthy.\n         * Otherwise check if the defaultValues for the key is truthy and if\n         * so push the value to the classes array.\n         */\n        if (\n          key in incomingProps ? incomingProps[key] : maybeDefaultValues[key]\n        ) {\n          classNames.push(value);\n        }\n        continue;\n      }\n      if (isRecord(value)) {\n        Object.entries(value).forEach(([k, v]) => {\n          if (\n            key in incomingProps\n              ? incomingProps[key] === k\n              : maybeDefaultValues[key] === k\n          ) {\n            classNames.push(v);\n          }\n        });\n        continue;\n      }\n      throw new Error(\n        `Invalid classifier value: ${value}. Classifier values must be a string or an object with string keys.`\n      );\n    }\n    return classNames;\n  }\n\n  // type Jsx\n\n  const jsxElem = getJsxElementFromArgs(arg2, arg3, arg4);\n\n  /**\n   * We specify the `props` as `className?: string` and ignoring the other\n   * props. This is not technically correct, but it satisfies the `className`\n   * type and we are doing the more strict checks in the overrides above.\n   *\n   * returns a forwardRef component\n   */\n  return forwardRef<React.ComponentRef<TagName>, { className?: string }>(\n    function __twux_component__({ className, ...props }, ref): JSX.Element {\n      const elementPropsWithoutClassNameAndClassifierKeys = omit(props, [\n        \"className\",\n        ...(maybeClassifier ? Object.keys(maybeClassifier) : []),\n      ]);\n\n      // Merge props with default class names\n      const mergedProps = {\n        ...mergeClassNamesIntoProps(\n          elementPropsWithoutClassNameAndClassifierKeys,\n          classify(props), // Apply default classes first\n          className // Append className from props last to override\n        ),\n        ref, // Attach the forwarded ref here\n      } as JSX.IntrinsicElements[TagName] & {\n        ref?: React.Ref<JSX.IntrinsicElements[TagName]>;\n      };\n\n      switch (jsxElem.type) {\n        case \"function-component\": {\n          const FunctionComponent = jsxElem.fn;\n          return <FunctionComponent {...mergedProps} />;\n        }\n        case \"tag-name\": {\n          /**\n           * We need to type cast `jsxElem.tag` to `React.ElementType` because\n           * `jsxElem.tag` can be an SVG type and that causes type issues. There\n           * is no easy to way to filter out the SVG types without doing it\n           * manually.\n           */\n          const Tag = jsxElem.tag as React.ElementType;\n          return <Tag {...mergedProps} />;\n        }\n      }\n    }\n  );\n}\n","export function isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nexport function omit<T extends Record<string, unknown>>(\n  obj: T,\n  keysToOmit: string[]\n): Record<string, unknown> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([key]) => !keysToOmit.includes(key))\n  );\n}\n\nexport function pick<T extends Record<string, unknown>>(\n  obj: T,\n  keysToPick: string[]\n): Record<string, unknown> {\n  return Object.fromEntries(\n    Object.entries(obj).filter(([key]) => keysToPick.includes(key))\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,mBAA4C;AAC5C,4BAAwB;;;ACFjB,SAAS,SAAS,OAAiC;AACxD,SAAO,OAAO,UAAU;AAC1B;AAEO,SAAS,WAAW,OAAmC;AAC5D,SAAO,OAAO,UAAU;AAC1B;AAEO,SAAS,SAAS,OAAkD;AACzE,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;AAEO,SAAS,KACd,KACA,YACyB;AACzB,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,OAAO,CAAC,CAAC,GAAG,MAAM,CAAC,WAAW,SAAS,GAAG,CAAC;AAAA,EACjE;AACF;;;ADTA,IAAAA,yBAA8B;AAoPb;AApOjB,SAAS,yBACJ,MAMS;AACZ,aAAW,OAAO,MAAM;AACtB,QAAI,SAAS,GAAG,EAAG,QAAO,EAAE,MAAM,YAAY,KAAK,IAAI;AACvD,QAAI,WAAW,GAAG,EAAG,QAAO,EAAE,MAAM,sBAAsB,IAAI,IAAI;AAAA,EACpE;AACA,QAAM,IAAI;AAAA,IACR;AAAA,EACF;AACF;AAYA,SAAS,yBACP,EAAE,WAAW,GAAG,MAAM,MACnB,SAC2C;AAC9C,QAAM,oBAAgB,+BAAQ,GAAG,SAAS,SAAS;AACnD,SAAO,EAAE,GAAG,OAAO,WAAW,cAAc;AAC9C;AAiHO,SAAS,KACd,WACA,MACA,MACA,MACU;AACV,QAAM,kBAAkB,SAAS,IAAI,IAAI,OAAO;AAChD,QAAM,qBACJ,mBAAmB,SAAS,IAAI,IAC5B,OACC,CAAC;AAER,WAAS,SAAS,eAAkD;AAClE,UAAM,aAAuB,CAAC,SAAS;AACvC,QAAI,CAAC,gBAAiB,QAAO;AAC7B,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,eAAe,GAAG;AAC1D,UAAI,SAAS,KAAK,GAAG;AAOnB,YACE,OAAO,gBAAgB,cAAc,GAAG,IAAI,mBAAmB,GAAG,GAClE;AACA,qBAAW,KAAK,KAAK;AAAA,QACvB;AACA;AAAA,MACF;AACA,UAAI,SAAS,KAAK,GAAG;AACnB,eAAO,QAAQ,KAAK,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM;AACxC,cACE,OAAO,gBACH,cAAc,GAAG,MAAM,IACvB,mBAAmB,GAAG,MAAM,GAChC;AACA,uBAAW,KAAK,CAAC;AAAA,UACnB;AAAA,QACF,CAAC;AACD;AAAA,MACF;AACA,YAAM,IAAI;AAAA,QACR,6BAA6B,KAAK;AAAA,MACpC;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAIA,QAAM,UAAU,sBAAsB,MAAM,MAAM,IAAI;AAStD,aAAO;AAAA,IACL,SAAS,mBAAmB,EAAE,WAAAC,YAAW,GAAG,MAAM,GAAG,KAAkB;AACrE,YAAM,gDAAgD,KAAK,OAAO;AAAA,QAChE;AAAA,QACA,GAAI,kBAAkB,OAAO,KAAK,eAAe,IAAI,CAAC;AAAA,MACxD,CAAC;AAGD,YAAM,cAAc;AAAA,QAClB,GAAG;AAAA,UACD;AAAA,UACA,SAAS,KAAK;AAAA;AAAA,UACdA;AAAA;AAAA,QACF;AAAA,QACA;AAAA;AAAA,MACF;AAIA,cAAQ,QAAQ,MAAM;AAAA,QACpB,KAAK,sBAAsB;AACzB,gBAAM,oBAAoB,QAAQ;AAClC,iBAAO,4CAAC,qBAAmB,GAAG,aAAa;AAAA,QAC7C;AAAA,QACA,KAAK,YAAY;AAOf,gBAAM,MAAM,QAAQ;AACpB,iBAAO,4CAAC,OAAK,GAAG,aAAa;AAAA,QAC/B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;","names":["import_tailwind_merge","className"]}